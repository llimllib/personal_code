#!/usr/bin/env bash
set -euo pipefail

function usage() {
        cat <<"EOF"
Usage: yt-transcript [options] <youtube-url>

Output a transcript of the given youtube video.

OPTIONS

  -help:          print this message
  -thumbs:        enable thumbnail generation
  -thumbinterval: the interval between thumbnails, in seconds [default 30]
  -v:             print more verbose output

DEPENDENCIES

Assumes you have installed:

- ffmpeg
- mlx_whisper
- yt-dlp
- python

To install all on a mac:

`brew install ffmpeg python yt-dlp && pip install mlx_whisper`

EXAMPLES

Create a transcript of a youtube video:

    yt-transcript 'https://www.youtube.com/watch?v=vP4iY1TtS3s'

Create a transcript with thumbnails every 30 seconds (the default):

    yt-transcript -thumbs 'https://www.youtube.com/watch?v=Ac7G7xOG2Ag'

Create a transcript with thumbnails every 10 seconds (the default):

    yt-transcript -thumbs -thumbinterval 10 'https://www.youtube.com/watch?v=X48G7Y0VWW4'
EOF
        exit 1
}
if [ -z "${1:-}" ]; then
    usage
fi

# default to suppressing ffmpeg and ytdlp output
ffmpegquiet=(-hide_banner -loglevel error)
ytdlpquiet=(--quiet)
thumbs=
thumbinterval=30 # default 30s between thumbs

# parse command line arguments
while true; do
    case $1 in
        -v)
            set -x
            ffmpegquiet=()
            ytdlpquiet=()
            shift
        ;;
        -thumbs)
            thumbs=yup
            shift
        ;;
        -thumbinterval)
            thumbinterval=$2
            shift 2
            break
        ;;
        -help)
            usage
        ;;
        *)
            break
        ;;
    esac
done

# verify requirements are installed
if ! command -v ffmpeg &> /dev/null
then
    printf "\033[31mYou must install ffmpeg\033[0m: https://ffmpeg.org/download.html\n\n"
fi

if ! command -v yt-dlp &> /dev/null
then
    printf "\033[31mYou must install yt-dlp\033[0m: https://github.com/yt-dlp/yt-dlp#installation\n\n"
    exit 1
fi

if ! command -v mlx_whisper &> /dev/null
then
    printf "\033[31mYou must install mlx_whisper\033[0m: https://pypi.org/project/mlx-whisper/\n\n"
    exit 1
fi

# create a sanitized version of the URL name to use as a cache key
yturl_clean=${1//[^a-zA-Z0-9]/}

# create the cache folder if it doesn't exist
yttranscript_cache_folder="/tmp/yttranscript_cache"
if [ ! -d $yttranscript_cache_folder ]; then
    mkdir $yttranscript_cache_folder
fi

# download audio of talk if we haven't yet
ytdl_audio_outfile="$yttranscript_cache_folder/rawaudio_$yturl_clean.%(ext)s"
rawaudio=$(find "$yttranscript_cache_folder" -name "rawaudio_$yturl_clean*")
if [ -z "$rawaudio" ]; then
    printf "\033[32mdownloading talk audio\033[0m\n"
    if ! yt-dlp -f ba "$1" \
        "${ytdlpquiet[@]}" \
        -o "$ytdl_audio_outfile"; then
        printf "\033[31mfailed running yt-dlp\033[0m\n"
        exit 1
    fi
fi
# re-run the `find` bc the file should exist now if it didn't before
rawaudio=$(find "$yttranscript_cache_folder" -name "rawaudio_$yturl_clean*")


# download video talk if we need it (thumbnails are requested) and haven't yet
ytdl_video_outfile="$yttranscript_cache_folder/rawvideo_$yturl_clean.%(ext)s"
rawvideo=$(find "$yttranscript_cache_folder" -name "rawvideo_$yturl_clean*")
if [ -n "$thumbs" ] && [ -z "$rawvideo" ]; then
    printf "\033[32mdownloading talk video\033[0m\n"
    if ! yt-dlp -f bv "$1" \
        "${ytdlpquiet[@]}" \
        -o "$ytdl_video_outfile"; then
        printf "\033[31mfailed running yt-dlp\033[0m\n"
        exit 1
    fi
fi
rawvideo=$(find "$yttranscript_cache_folder" -name "rawvideo_$yturl_clean*")


# convert into 16-bit wav file if we haven't yet
wavfile="$yttranscript_cache_folder/audio_$yturl_clean.wav"
if [ ! -f "$wavfile" ]; then
    printf "\033[32mconverting to wav\033[0m\n"
    if ! ffmpeg -y "${ffmpegquiet[@]}" \
        -i "${rawaudio}" \
        -ar 16000 -ac 1 -c:a pcm_s16le \
        "$wavfile"; then
        printf "\033[31mfailed running ffmpeg\033[0m\n"
        exit 1
    fi
fi

# Create an HTML file to display. We'll add the text of the talk in the next
# branch
transcript_html="$yttranscript_cache_folder/$yturl_clean.html"
cat <<EOF >"$transcript_html"
<html><head><style>
body {
  font-family: Georgia, "Book Antiqua", serif;
  padding-top: 100px;
  margin: auto;
  justify-content: center;
  color: #333;
  width: 800px;
}
p {
  font-size: 18px;
  line-height: 30px;
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
}
</style></head><body><p><em>transcript of <a href="$1">$1</a></em><p>
EOF

# if no thumbs are requested, convert it into a text file and make an HTML page
if [ -z "$thumbs" ]; then
    # Convert it into a text file
    # mlx_whisper saves the input file into an output dir with the same filename
    # but with .txt instead of .wav. I wish it had an option to specify file output
    # name but it does not
    transcript="$yttranscript_cache_folder/audio_$yturl_clean.txt"
    if [ ! -f "$transcript" ]; then
        printf "\033[32mtranscribing\033[0m\n"
        if ! mlx_whisper --model 'mlx-community/distil-whisper-large-v3' \
                 -f txt \
                 -o "$yttranscript_cache_folder" \
                 --verbose False \
                 "$wavfile"; then
            printf "\033[31mfailed running whisper.cpp\033[0m\n"
            exit 1
        fi
        # if ! whisper-cpp -np -otxt \
        #     -m ~/.local/share/blisper/ggml-distil-large-v3.bin ./input.wav \
        #     -of "$transcriptArg"; then
        #     printf "\033[31mfailed running whisper.cpp\033[0m\n"
        #     exit 1
        # fi
    fi
    sed -E 's/([.?])$/\1<p>/' "$transcript" >> "$transcript_html"
else

    # Get the duration of the audio file using ffprobe
    duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$wavfile")

    # Convert duration to seconds
    duration_sec=$(printf "%.0f" "$duration")

    intervals=
    if [ "$duration_sec" -gt "$thumbinterval" ]; then
        # Loop through the duration in 30-second intervals and build a string for
        # the clip-timestamps option of mlx_whisper
        intervals="0,$thumbinterval"
        max=
        for ((i=0; i+thumbinterval<"$duration_sec"; i+=thumbinterval)); do
            intervals="$intervals,$i,$((i+thumbinterval))"
            max=$((i+thumbinterval))
        done
        intervals="$intervals,$max"
    fi

    # transcribe the video into json format, clipping at 30-second intervals
    transcript="$yttranscript_cache_folder/audio_$yturl_clean.json"
    if [ ! -f "$transcript" ]; then
        printf "\033[32mtranscribing\033[0m\n"
        if ! mlx_whisper --model 'mlx-community/distil-whisper-large-v3' \
                 -f json \
                 -o "$yttranscript_cache_folder" \
                 --verbose False \
                 --clip-timestamps "${intervals[@]}" \
                 "$wavfile"; then
            printf "\033[31mfailed running whisper.cpp\032[0m\n"
            exit 1
        fi
    fi

    # Now loop through the intervals and output the HTML accordingly
    for ((i=0; i<="$duration_sec"; i+=thumbinterval)); do
        imgName="${yturl_clean}_thumb_$i.jpg"
        img="$yttranscript_cache_folder/$imgName"
        # I tried to find a video filter here that would avoid the initial
        # black frame I'm seeing, but was unsuccessful. Some attempts:
        #
        #-vf "select='eq(n,0)+eq(pict_type,PICT_TYPE_I)+gt(scene,0.3)',scale=320:240,unsharp" \
        #-vf "select='gt(scene,0.3)',scale=320:240,unsharp" \
        #-vf "select='eq(pict_type,PICT_TYPE_I)',scale=320:240,unsharp" \
        #
        # instaed I'm just pulling the frame from 1 second into the segment
        # instead of zero, which is a pretty lame thing to do
        ffmpeg -ss "$((i+1))" -i "$rawvideo" \
            -vf "select='eq(n,0)+eq(pict_type,PICT_TYPE_I)+gt(scene,0.3)',scale=320:240,unsharp" \
            -vframes 1 -q:v 2 "$img" -y &> /dev/null
        printf '<img src="./%s"><p>' "$imgName" >> "$transcript_html"
        segment=$(cat "$transcript" |
            jq -r $"[.segments[] | select(.start >= $i and .start < $((i+thumbinterval))).text] | join(\"<p>\n\")")
        printf "%s<p>\n" "$segment" >> "$transcript_html"
    done
fi

printf '</body>' >> "$transcript_html"

open "$transcript_html"
